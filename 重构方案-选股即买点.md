# 重构方案：选股即买点

## 问题诊断

### 当前问题
```
选股系统选出300350，但最新B信号是4天前
→ 用户看到被选中，以为可以买
→ 实际上已经涨过了，不是最佳买点
→ 逻辑混乱！
```

### 根本原因
```
选股逻辑 ≠ 信号逻辑
- 选股：检查技术条件（宽松）
- 信号：标记买卖点（严格+去重）
- 两者分离导致不一致
```

---

## 重构目标

### ✅ 新逻辑
```
选股结果 = 今天有买入信号的股票

IF 选股系统选出某只股票:
    → 说明今天或最近1-2天出现了买入信号
    → 可以立即考虑买入
    → 逻辑清晰！
```

---

## 重构方案

### 方案1：选股时检查信号（推荐⭐）

#### 修改 `BreakoutPreviousHighSelector.select()`

**重构前**：
```python
def select(self, date, data):
    picks = []
    for code, df in data.items():
        if self._passes_filters(df):  # 只检查技术条件
            picks.append(code)
    return picks
```

**重构后**：
```python
def select(self, date, data):
    picks = []
    for code, df in data.items():
        # 1. 基础技术条件
        if not self._passes_filters(df):
            continue
        
        # 2. 必须有最新的买入信号
        signals = self._identify_signals(df)
        b_signals = [s for s in signals if s['type'] == 'B']
        
        if not b_signals:
            continue
        
        # 3. 最新信号必须在最近2天内
        latest_signal_date = max(b_signals, key=lambda x: x['date'])['date']
        days_since_signal = (date - latest_signal_date).days
        
        if days_since_signal <= 2:  # 只选最近2天有信号的
            picks.append(code)
    
    return picks
```

---

### 方案2：在_passes_filters中增加信号检查

**思路**：在技术条件检查的最后一步，验证当日是否有信号

```python
def _passes_filters(self, hist):
    # ... 原有的所有技术条件检查 ...
    
    # 最后：检查当日或最近2天是否有信号
    signals = self._identify_signals(hist)
    b_signals = [s for s in signals if s['type'] == 'B']
    
    if not b_signals:
        return False
    
    latest_date = max(s['date'] for s in b_signals)
    current_date = hist.iloc[-1]['date']
    
    if (current_date - latest_date).days > 2:
        return False
    
    return True
```

---

### 方案3：完全统一逻辑（彻底重构）

**思路**：选股逻辑 = 信号识别逻辑

```python
class BreakoutPreviousHighSelector:
    def select(self, date, data):
        picks = []
        
        for code, df in data.items():
            # 使用Web系统的信号识别逻辑
            df_with_signals = self._add_signals(df)
            
            # 只选今天有B信号的
            today_signals = df_with_signals[
                (df_with_signals['date'] == date) &
                (df_with_signals['signal'] == 'B')
            ]
            
            if not today_signals.empty:
                picks.append(code)
        
        return picks
    
    def _add_signals(self, df):
        """复用Web系统的信号识别逻辑"""
        # 调用web_app.py中的_identify_breakout_signals
        from web_app import StockSelector
        selector = StockSelector.__new__(StockSelector)
        return selector._identify_breakout_signals(df)
```

---

## 推荐实施方案

### 阶段1：快速修复（立即实施）

修改`Selector.py`中的`BreakoutPreviousHighSelector`：

```python
def _passes_filters(self, hist: pd.DataFrame) -> bool:
    # ... 原有所有检查 ...
    
    # 新增：最后检查当日是否是信号日
    # 简化版：直接检查当日是否满足B信号的核心条件
    
    close_today = float(hist.iloc[-1]['close'])
    vol_today = float(hist.iloc[-1]['volume'])
    
    # 计算前高
    prev_high = float(hist.iloc[-60:-5]['high'].max())
    distance_pct = (prev_high - close_today) / prev_high
    
    # 计算量比
    vol_ma5 = float(hist.iloc[-6:-1]['volume'].mean())
    vol_ratio = vol_today / vol_ma5 if vol_ma5 > 0 else 0
    
    # 核心条件：必须是潜在的B信号日
    if not (-0.05 <= distance_pct <= 0.25 and vol_ratio >= 1.2):
        return False
    
    # 检查最近5天内是否已有相似的突破
    # 如果有，说明不是新的买点，过滤掉
    for i in range(max(0, len(hist)-6), len(hist)-1):
        prev_close = hist.iloc[i]['close']
        prev_vol = hist.iloc[i]['volume']
        prev_vol_ratio = prev_vol / vol_ma5 if vol_ma5 > 0 else 0
        prev_dist = (prev_high - prev_close) / prev_high
        
        if (-0.05 <= prev_dist <= 0.25 and prev_vol_ratio >= 1.2):
            # 最近已经有类似的信号了，说明不是新买点
            return False
    
    return True
```

---

### 阶段2：完整重构（建议方案）

#### 步骤1：创建统一的信号识别模块

```python
# signal_identifier.py
class SignalIdentifier:
    """统一的信号识别逻辑，选股和Web都使用"""
    
    @staticmethod
    def identify_breakout_signals(df):
        """出坑战法信号识别"""
        # ... 完整的信号识别逻辑 ...
        return signals
    
    @staticmethod
    def identify_shaofv_signals(df):
        """少妇战法信号识别"""
        # ... 完整的信号识别逻辑 ...
        return signals
```

#### 步骤2：选股器调用信号识别

```python
# Selector.py
from signal_identifier import SignalIdentifier

class BreakoutPreviousHighSelector:
    def select(self, date, data):
        picks = []
        
        for code, df in data.items():
            # 使用统一的信号识别
            signals = SignalIdentifier.identify_breakout_signals(df)
            
            # 只选今天或昨天有B信号的
            recent_b = [s for s in signals 
                       if s['type'] == 'B' and 
                       (date - s['date']).days <= 1]
            
            if recent_b:
                picks.append(code)
        
        return picks
```

#### 步骤3：Web系统也使用统一逻辑

```python
# web_app.py
from signal_identifier import SignalIdentifier

class StockSelector:
    def _identify_breakout_signals(self, df):
        # 直接调用统一逻辑
        return SignalIdentifier.identify_breakout_signals(df)
```

---

## 对比效果

### 重构前
```
11-21 选股结果:
  300350 ✅ 被选中
  
查看K线图:
  最新B信号: 11-17（4天前）
  
用户困惑: 
  "为什么选出来的不能买？"
```

### 重构后
```
11-21 选股结果:
  (假设300350在11-21没有新的B信号)
  300350 ❌ 不选中（最新信号是4天前）
  
或者:
  (假设300350在11-21出现新的B信号)
  300350 ✅ 被选中
  
查看K线图:
  最新B信号: 11-21（今天！）
  
用户清晰:
  "选出来的就可以买！"
```

---

## 实施建议

### 快速方案（今天就能改）
1. 修改`_passes_filters`，增加"最近5天内无重复信号"检查
2. 确保选出的股票都是"今天才出现信号"的

### 完整方案（花1-2小时）
1. 创建`signal_identifier.py`统一模块
2. 选股器调用统一信号识别
3. Web系统也调用统一信号识别
4. 删除重复代码

---

## 测试验证

### 测试用例1：300350
```
假设数据:
  11-17: 满足B信号条件 → 识别为B信号
  11-18-11-20: 不满足 → 无信号
  11-21: 满足技术条件，但5天内有信号 → 过滤掉

预期结果:
  11-17: ✅ 被选出
  11-21: ❌ 不选出
```

### 测试用例2：理想情况
```
假设数据:
  11-10: 有B信号
  11-11-11-20: 无信号
  11-21: 满足B信号条件，且5天内无重复 → 新的B信号

预期结果:
  11-10: ✅ 被选出
  11-21: ✅ 被选出
```

---

## 我的建议

**立即实施快速方案**，让选股结果更准确：

1. 修改`BreakoutPreviousHighSelector._passes_filters`
2. 增加"5天内无重复信号"检查
3. 确保选出的都是"新鲜的买点"

然后再考虑完整重构，统一代码。

你觉得这个方向对吗？我现在就可以开始改！

